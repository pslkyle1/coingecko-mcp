// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { endpoints, query } from "./tools.mjs";
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import Coingecko from '@coingecko/coingecko-typescript';
import { applyCompatibilityTransformations, defaultClientCapabilities, knownClients, parseEmbeddedJSON, } from "./compat.mjs";
import { dynamicTools } from "./dynamic-tools.mjs";
export { endpoints } from "./tools.mjs";
// Create server instance
export const server = new McpServer({
    name: 'coingecko_coingecko_typescript_api',
    version: '1.7.3',
}, {
    capabilities: {
        tools: {},
    },
});
/**
 * Initializes the provided MCP Server with the given tools and handlers.
 * If not provided, the default client, tools and handlers will be used.
 */
export function initMcpServer(params) {
    const transformedEndpoints = selectTools(endpoints, params.mcpOptions);
    const client = new Coingecko(params.clientOptions);
    const capabilities = {
        ...defaultClientCapabilities,
        ...(params.mcpOptions.client ? knownClients[params.mcpOptions.client] : params.mcpOptions.capabilities),
    };
    init({ server: params.server, client, endpoints: transformedEndpoints, capabilities });
}
export function init(params) {
    const server = params.server instanceof McpServer ? params.server.server : params.server;
    const providedEndpoints = params.endpoints || endpoints;
    const endpointMap = Object.fromEntries(providedEndpoints.map((endpoint) => [endpoint.tool.name, endpoint]));
    const client = params.client ||
        new Coingecko({
            environment: (readEnv('COINGECKO_ENVIRONMENT') || undefined),
            defaultHeaders: { 'X-Stainless-MCP': 'true' },
        });
    server.setRequestHandler(ListToolsRequestSchema, async () => {
        return {
            tools: providedEndpoints.map((endpoint) => endpoint.tool),
        };
    });
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
        const { name, arguments: args } = request.params;
        const endpoint = endpointMap[name];
        if (!endpoint) {
            throw new Error(`Unknown tool: ${name}`);
        }
        return executeHandler(endpoint.tool, endpoint.handler, client, args, params.capabilities);
    });
}
/**
 * Selects the tools to include in the MCP Server based on the provided options.
 */
export function selectTools(endpoints, options) {
    const filteredEndpoints = query(options.filters, endpoints);
    let includedTools = filteredEndpoints;
    if (includedTools.length > 0) {
        if (options.includeDynamicTools) {
            includedTools = dynamicTools(includedTools);
        }
    }
    else {
        if (options.includeAllTools) {
            includedTools = endpoints;
        }
        else if (options.includeDynamicTools) {
            includedTools = dynamicTools(endpoints);
        }
        else {
            includedTools = endpoints;
        }
    }
    const capabilities = { ...defaultClientCapabilities, ...options.capabilities };
    return applyCompatibilityTransformations(includedTools, capabilities);
}
/**
 * Runs the provided handler with the given client and arguments.
 */
export async function executeHandler(tool, handler, client, args, compatibilityOptions) {
    const options = { ...defaultClientCapabilities, ...compatibilityOptions };
    if (options.validJson && args) {
        args = parseEmbeddedJSON(args, tool.inputSchema);
    }
    return await handler(client, args || {});
}
export const readEnv = (env) => {
    if (typeof globalThis.process !== 'undefined') {
        return globalThis.process.env?.[env]?.trim();
    }
    else if (typeof globalThis.Deno !== 'undefined') {
        return globalThis.Deno.env?.get?.(env)?.trim();
    }
    return;
};
export const readEnvOrError = (env) => {
    let envValue = readEnv(env);
    if (envValue === undefined) {
        throw new Error(`Environment variable ${env} is not set`);
    }
    return envValue;
};
//# sourceMappingURL=server.mjs.map