import type { RequestInit, RequestInfo } from "./internal/builtin-types.mjs";
import type { PromiseOrValue, MergedRequestInit, FinalizedRequestInit } from "./internal/types.mjs";
export type { Logger, LogLevel } from "./internal/utils/log.mjs";
import * as Opts from "./internal/request-options.mjs";
import * as Errors from "./core/error.mjs";
import * as Uploads from "./core/uploads.mjs";
import * as API from "./resources/index.mjs";
import { APIPromise } from "./core/api-promise.mjs";
import { AssetPlatformGetParams, AssetPlatformGetResponse, AssetPlatforms } from "./resources/asset-platforms.mjs";
import { ExchangeRateGetResponse, ExchangeRates } from "./resources/exchange-rates.mjs";
import { Key, KeyGetResponse } from "./resources/key.mjs";
import { Ping, PingGetResponse } from "./resources/ping.mjs";
import { TokenListGetAllJsonResponse, TokenLists } from "./resources/token-lists.mjs";
import { CoinGetIDParams, CoinGetIDResponse, Coins } from "./resources/coins/coins.mjs";
import { Companies } from "./resources/companies/companies.mjs";
import { DerivativeGetResponse, Derivatives } from "./resources/derivatives/derivatives.mjs";
import { ExchangeGetIDParams, ExchangeGetIDResponse, ExchangeGetListParams, ExchangeGetListResponse, ExchangeGetParams, ExchangeGetResponse, Exchanges } from "./resources/exchanges/exchanges.mjs";
import { Global, GlobalGetResponse } from "./resources/global/global.mjs";
import { NFTGetIDResponse, NFTGetListParams, NFTGetListResponse, NFTGetMarketsParams, NFTGetMarketsResponse, NFTs } from "./resources/nfts/nfts.mjs";
import { Onchain } from "./resources/onchain/onchain.mjs";
import { Search, SearchGetParams, SearchGetResponse } from "./resources/search/search.mjs";
import { Simple } from "./resources/simple/simple.mjs";
import { type Fetch } from "./internal/builtin-types.mjs";
import { HeadersLike, NullableHeaders } from "./internal/headers.mjs";
import { FinalRequestOptions, RequestOptions } from "./internal/request-options.mjs";
import { type LogLevel, type Logger } from "./internal/utils/log.mjs";
declare const environments: {
    pro: string;
    demo: string;
};
type Environment = keyof typeof environments;
export interface ClientOptions {
    /**
     * CoinGecko Pro API Key
     */
    proAPIKey?: string | null | undefined;
    /**
     * CoinGecko Demo API Key
     */
    demoAPIKey?: string | null | undefined;
    /**
     * Specifies the environment to use for the API.
     *
     * Each environment maps to a different base URL:
     * - `pro` corresponds to `https://pro-api.coingecko.com/api/v3`
     * - `demo` corresponds to `https://api.coingecko.com/api/v3`
     */
    environment?: Environment | undefined;
    /**
     * Override the default base URL for the API, e.g., "https://api.example.com/v2/"
     *
     * Defaults to process.env['COINGECKO_BASE_URL'].
     */
    baseURL?: string | null | undefined;
    /**
     * The maximum amount of time (in milliseconds) that the client should wait for a response
     * from the server before timing out a single request.
     *
     * Note that request timeouts are retried by default, so in a worst-case scenario you may wait
     * much longer than this timeout before the promise succeeds or fails.
     *
     * @unit milliseconds
     */
    timeout?: number | undefined;
    /**
     * Additional `RequestInit` options to be passed to `fetch` calls.
     * Properties will be overridden by per-request `fetchOptions`.
     */
    fetchOptions?: MergedRequestInit | undefined;
    /**
     * Specify a custom `fetch` function implementation.
     *
     * If not provided, we expect that `fetch` is defined globally.
     */
    fetch?: Fetch | undefined;
    /**
     * The maximum number of times that the client will retry a request in case of a
     * temporary failure, like a network error or a 5XX error from the server.
     *
     * @default 2
     */
    maxRetries?: number | undefined;
    /**
     * Default headers to include with every request to the API.
     *
     * These can be removed in individual requests by explicitly setting the
     * header to `null` in request options.
     */
    defaultHeaders?: HeadersLike | undefined;
    /**
     * Default query parameters to include with every request to the API.
     *
     * These can be removed in individual requests by explicitly setting the
     * param to `undefined` in request options.
     */
    defaultQuery?: Record<string, string | undefined> | undefined;
    /**
     * Set the log level.
     *
     * Defaults to process.env['COINGECKO_LOG'] or 'warn' if it isn't set.
     */
    logLevel?: LogLevel | undefined;
    /**
     * Set the logger.
     *
     * Defaults to globalThis.console.
     */
    logger?: Logger | undefined;
}
/**
 * API Client for interfacing with the Coingecko API.
 */
export declare class Coingecko {
    #private;
    proAPIKey: string | null;
    demoAPIKey: string | null;
    baseURL: string;
    maxRetries: number;
    timeout: number;
    logger: Logger | undefined;
    logLevel: LogLevel | undefined;
    fetchOptions: MergedRequestInit | undefined;
    private fetch;
    protected idempotencyHeader?: string;
    private _options;
    /**
     * API Client for interfacing with the Coingecko API.
     *
     * @param {string | null | undefined} [opts.proAPIKey=process.env['COINGECKO_PRO_API_KEY'] ?? null]
     * @param {string | null | undefined} [opts.demoAPIKey=process.env['COINGECKO_DEMO_API_KEY'] ?? null]
     * @param {Environment} [opts.environment=pro] - Specifies the environment URL to use for the API.
     * @param {string} [opts.baseURL=process.env['COINGECKO_BASE_URL'] ?? https://pro-api.coingecko.com/api/v3] - Override the default base URL for the API.
     * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
     * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
     * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
     * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
     * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
     */
    constructor({ baseURL, proAPIKey, demoAPIKey, ...opts }?: ClientOptions);
    /**
     * Create a new client instance re-using the same options given to the current client with optional overriding.
     */
    withOptions(options: Partial<ClientOptions>): this;
    protected defaultQuery(): Record<string, string | undefined> | undefined;
    protected validateHeaders({ values, nulls }: NullableHeaders): void;
    protected authHeaders(opts: FinalRequestOptions): NullableHeaders | undefined;
    protected proKeyAuth(opts: FinalRequestOptions): NullableHeaders | undefined;
    protected demoKeyAuth(opts: FinalRequestOptions): NullableHeaders | undefined;
    /**
     * Basic re-implementation of `qs.stringify` for primitive types.
     */
    protected stringifyQuery(query: Record<string, unknown>): string;
    private getUserAgent;
    protected defaultIdempotencyKey(): string;
    protected makeStatusError(status: number, error: Object, message: string | undefined, headers: Headers): Errors.APIError;
    buildURL(path: string, query: Record<string, unknown> | null | undefined, defaultBaseURL?: string | undefined): string;
    /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
     */
    protected prepareOptions(options: FinalRequestOptions): Promise<void>;
    /**
     * Used as a callback for mutating the given `RequestInit` object.
     *
     * This is useful for cases where you want to add certain headers based off of
     * the request properties, e.g. `method` or `url`.
     */
    protected prepareRequest(request: RequestInit, { url, options }: {
        url: string;
        options: FinalRequestOptions;
    }): Promise<void>;
    get<Rsp>(path: string, opts?: PromiseOrValue<RequestOptions>): APIPromise<Rsp>;
    post<Rsp>(path: string, opts?: PromiseOrValue<RequestOptions>): APIPromise<Rsp>;
    patch<Rsp>(path: string, opts?: PromiseOrValue<RequestOptions>): APIPromise<Rsp>;
    put<Rsp>(path: string, opts?: PromiseOrValue<RequestOptions>): APIPromise<Rsp>;
    delete<Rsp>(path: string, opts?: PromiseOrValue<RequestOptions>): APIPromise<Rsp>;
    private methodRequest;
    request<Rsp>(options: PromiseOrValue<FinalRequestOptions>, remainingRetries?: number | null): APIPromise<Rsp>;
    private makeRequest;
    fetchWithTimeout(url: RequestInfo, init: RequestInit | undefined, ms: number, controller: AbortController): Promise<Response>;
    private shouldRetry;
    private retryRequest;
    private calculateDefaultRetryTimeoutMillis;
    buildRequest(inputOptions: FinalRequestOptions, { retryCount }?: {
        retryCount?: number;
    }): {
        req: FinalizedRequestInit;
        url: string;
        timeout: number;
    };
    private buildHeaders;
    private buildBody;
    static Coingecko: typeof Coingecko;
    static DEFAULT_TIMEOUT: number;
    static CoingeckoError: typeof Errors.CoingeckoError;
    static APIError: typeof Errors.APIError;
    static APIConnectionError: typeof Errors.APIConnectionError;
    static APIConnectionTimeoutError: typeof Errors.APIConnectionTimeoutError;
    static APIUserAbortError: typeof Errors.APIUserAbortError;
    static NotFoundError: typeof Errors.NotFoundError;
    static ConflictError: typeof Errors.ConflictError;
    static RateLimitError: typeof Errors.RateLimitError;
    static BadRequestError: typeof Errors.BadRequestError;
    static AuthenticationError: typeof Errors.AuthenticationError;
    static InternalServerError: typeof Errors.InternalServerError;
    static PermissionDeniedError: typeof Errors.PermissionDeniedError;
    static UnprocessableEntityError: typeof Errors.UnprocessableEntityError;
    static toFile: typeof Uploads.toFile;
    assetPlatforms: API.AssetPlatforms;
    coins: API.Coins;
    companies: API.Companies;
    derivatives: API.Derivatives;
    exchangeRates: API.ExchangeRates;
    exchanges: API.Exchanges;
    global: API.Global;
    key: API.Key;
    nfts: API.NFTs;
    onchain: API.Onchain;
    ping: API.Ping;
    search: API.Search;
    simple: API.Simple;
    tokenLists: API.TokenLists;
}
export declare namespace Coingecko {
    export type RequestOptions = Opts.RequestOptions;
    export { AssetPlatforms as AssetPlatforms, type AssetPlatformGetResponse as AssetPlatformGetResponse, type AssetPlatformGetParams as AssetPlatformGetParams, };
    export { Coins as Coins, type CoinGetIDResponse as CoinGetIDResponse, type CoinGetIDParams as CoinGetIDParams, };
    export { Companies as Companies };
    export { Derivatives as Derivatives, type DerivativeGetResponse as DerivativeGetResponse };
    export { ExchangeRates as ExchangeRates, type ExchangeRateGetResponse as ExchangeRateGetResponse };
    export { Exchanges as Exchanges, type ExchangeGetResponse as ExchangeGetResponse, type ExchangeGetIDResponse as ExchangeGetIDResponse, type ExchangeGetListResponse as ExchangeGetListResponse, type ExchangeGetParams as ExchangeGetParams, type ExchangeGetIDParams as ExchangeGetIDParams, type ExchangeGetListParams as ExchangeGetListParams, };
    export { Global as Global, type GlobalGetResponse as GlobalGetResponse };
    export { Key as Key, type KeyGetResponse as KeyGetResponse };
    export { NFTs as NFTs, type NFTGetIDResponse as NFTGetIDResponse, type NFTGetListResponse as NFTGetListResponse, type NFTGetMarketsResponse as NFTGetMarketsResponse, type NFTGetListParams as NFTGetListParams, type NFTGetMarketsParams as NFTGetMarketsParams, };
    export { Onchain as Onchain };
    export { Ping as Ping, type PingGetResponse as PingGetResponse };
    export { Search as Search, type SearchGetResponse as SearchGetResponse, type SearchGetParams as SearchGetParams, };
    export { Simple as Simple };
    export { TokenLists as TokenLists, type TokenListGetAllJsonResponse as TokenListGetAllJsonResponse };
}
//# sourceMappingURL=client.d.mts.map