// src/helpers.ts
var parse$ref = (ref) => {
  const parts = ref.split("#");
  return {
    $id: parts[0],
    $path: parts[1].split("/").filter((part) => part != "")
  };
};
function deepMerge(target, source) {
  const result = Array(target) && Array.isArray(source) ? target.concat(source) : { ...target, ...source };
  for (const key of Object.keys(result)) {
    result[key] = typeof target[key] == "object" && typeof source[key] == "object" ? deepMerge(target[key], source[key]) : structuredClone(result[key]);
  }
  return result;
}
var traverseSchema = (options, definitions, obj) => {
  const ts = (obj2, cb) => {
    let hits;
    do {
      hits = 0;
      for (const key of Object.keys(obj2)) {
        if (typeof obj2[key] == "object") {
          ts(obj2[key], (value) => {
            obj2[key] = value;
            hits++;
          });
          if (options.useMerge && key == "$merge") {
            const merge = deepMerge(obj2[key].source, obj2[key].with);
            if (cb) {
              cb(merge);
            } else {
              hits++;
              Object.assign(obj2, merge);
              delete obj2[key];
            }
          }
        } else {
          if (key == "$ref") {
            const { $id, $path } = parse$ref(obj2[key]);
            const { resolvedObject } = resolvePayload($path, definitions[$id]);
            if (resolvedObject) {
              if (cb) {
                cb(resolvedObject);
              } else {
                hits++;
                Object.assign(obj2, resolvedObject);
                delete obj2[key];
              }
            } else {
              throw new Error(`Could not resolve '${obj2[key]}' $ref`);
            }
          }
        }
      }
    } while (hits > 0);
  };
  ts(obj);
};
var resolvePayload = (path, obj) => {
  let resolvedObject = path.reduce(function(prev, curr) {
    return prev ? prev[curr] : void 0;
  }, obj);
  return { metadata: getMetaData(resolvedObject), resolvedObject };
};
var pathToString = (path) => {
  return path.length == 0 ? `/` : path.map((item) => `/${item}`).join("");
};
var getMetaData = (value) => {
  let size = 0;
  let types = /* @__PURE__ */ new Set([]);
  let properties = [];
  if (value === null) {
    types.add("null");
  } else if (typeof value == "string") {
    types.add("string");
    size = value.length;
  } else if (typeof value == "number") {
    size = 1;
    types.add("number");
    if (Number.isInteger(value)) {
      types.add("integer");
    }
  } else if (typeof value == "boolean") {
    types.add("boolean");
    size = 1;
  } else if (Array.isArray(value)) {
    size = value.length;
    types.add("array");
    if (value.find((item) => typeof item !== "number" && typeof item !== "string") == void 0) {
      types.add("binary");
    }
  } else if (typeof value == "object") {
    types.add("object");
    size = Object.keys(value).length;
    properties = Object.keys(value);
  }
  return { types, size, properties };
};

// src/index.ts
var Cabidela = class {
  schema;
  options;
  definitions = {};
  constructor(schema, options) {
    this.schema = schema;
    this.options = {
      fullErrors: true,
      subSchemas: [],
      applyDefaults: false,
      errorMessages: false,
      ...options || {}
    };
    if (this.schema.hasOwnProperty("$defs")) {
      this.definitions["$defs"] = this.schema["$defs"];
      delete this.schema["$defs"];
    }
    if (this.options.subSchemas.length > 0) {
      for (const subSchema of this.options.subSchemas) {
        this.addSchema(subSchema, false);
      }
    }
    if (this.options.useMerge || this.options.subSchemas.length > 0) {
      traverseSchema(this.options, this.definitions, this.schema);
    }
  }
  setSchema(schema) {
    this.schema = schema;
  }
  addSchema(subSchema, combine = true) {
    if (subSchema.hasOwnProperty("$id")) {
      const url = URL.parse(subSchema["$id"]);
      if (url) {
        this.definitions[url.pathname.split("/").slice(-1)[0]] = subSchema;
      } else {
        throw new Error(
          "subSchemas need a valid retrieval URI $id https://json-schema.org/understanding-json-schema/structuring#retrieval-uri"
        );
      }
    } else {
      throw new Error("subSchemas need $id https://json-schema.org/understanding-json-schema/structuring#id");
    }
    if (combine == true) traverseSchema(this.options, this.definitions, this.schema);
  }
  getSchema() {
    return this.schema;
  }
  setOptions(options) {
    this.options = { ...this.options, ...options };
  }
  throw(message, needle) {
    const error = `${message}${this.options.fullErrors && needle.absorvErrors !== true && needle.errors.size > 0 ? `: ${Array.from(needle.errors).join(", ")}` : ``}`;
    throw new Error(this.options.errorMessages ? needle.schema.errorMessage ?? error : error);
  }
  parseAdditionalProperties(needle, contextAdditionalProperties, contextEvaluatedProperties) {
    let matchCount = 0;
    const { metadata, resolvedObject } = resolvePayload(needle.path, needle.payload);
    const unevaluatedProperties = new Set(
      metadata.properties.map((r) => pathToString([...needle.path, r]))
    ).difference(contextEvaluatedProperties);
    if (contextAdditionalProperties === false) {
      if (unevaluatedProperties.size > 0) {
        this.throw(
          `Additional or unevaluated properties '${Array.from(unevaluatedProperties).join(", ")}' at '${pathToString(needle.path)}' not allowed`,
          {
            ...needle,
            schema: contextAdditionalProperties,
            payload: resolvedObject
          }
        );
      }
    } else {
      for (let property of unevaluatedProperties) {
        if (this.parseSubSchema({
          path: [property.split("/").slice(-1)[0]],
          schema: contextAdditionalProperties,
          payload: resolvedObject,
          evaluatedProperties: /* @__PURE__ */ new Set(),
          errors: /* @__PURE__ */ new Set(),
          defaultsCallbacks: []
        })) {
          matchCount++;
          needle.evaluatedProperties.add(pathToString([property]));
        }
      }
    }
    return matchCount;
  }
  // Iterates through the properties of an "object" schema
  parseObject(needle) {
    if (needle.schema.hasOwnProperty("minProperties")) {
      if (Object.keys(needle.payload).length < needle.schema.minProperties) {
        this.throw(
          `minProperties at '${pathToString(needle.path)}' is ${needle.schema.minProperties}, got ${Object.keys(needle.payload).length}`,
          needle
        );
      }
    }
    if (needle.schema.hasOwnProperty("maxProperties")) {
      if (Object.keys(needle.payload).length > needle.schema.maxProperties) {
        this.throw(
          `maxProperties at '${pathToString(needle.path)}' is ${needle.schema.minProperties}, got ${Object.keys(needle.payload).length}`,
          needle
        );
      }
    }
    const localEvaluatedProperties = /* @__PURE__ */ new Set([]);
    let matchCount = 0;
    if (needle.schema.hasOwnProperty("properties")) {
      for (let property in needle.schema.properties) {
        const matches = this.parseSubSchema({
          ...needle,
          path: [...needle.path, property],
          schema: needle.schema.properties[property]
        });
        if (matches > 0) {
          localEvaluatedProperties.add(pathToString([...needle.path, property]));
          matchCount++;
        }
      }
    }
    if (needle.schema.hasOwnProperty("additionalProperties")) {
      matchCount += this.parseAdditionalProperties(
        needle,
        needle.schema.additionalProperties,
        localEvaluatedProperties
      );
    }
    if (needle.schema.hasOwnProperty("unevaluatedProperties")) {
      needle.evaluatedProperties = /* @__PURE__ */ new Set([...needle.evaluatedProperties, ...localEvaluatedProperties]);
      matchCount += this.parseAdditionalProperties(
        needle,
        needle.schema.unevaluatedProperties,
        needle.evaluatedProperties
      );
    }
    if (needle.schema.hasOwnProperty("required")) {
      if (new Set(needle.schema.required.map((r) => pathToString([...needle.path, r]))).difference(
        needle.evaluatedProperties.union(localEvaluatedProperties)
      ).size > 0) {
        this.throw(`required properties at '${pathToString(needle.path)}' are '${needle.schema.required}'`, needle);
      }
    }
    return matchCount ? true : false;
  }
  parseList(list, needle, breakCondition) {
    let rounds = 0;
    const defaultsCallbacks = [];
    for (let option in list) {
      try {
        const matches = this.parseSubSchema({
          ...needle,
          schema: { type: needle.schema.type, ...list[option] },
          carryProperties: false,
          absorvErrors: true,
          deferredApplyDefaults: true
        });
        rounds += matches;
        if (breakCondition && breakCondition(rounds)) break;
        defaultsCallbacks.push(...needle.defaultsCallbacks);
        needle.defaultsCallbacks = [];
      } catch (e) {
        needle.errors.add(e.message);
        needle.defaultsCallbacks = [];
      }
    }
    for (const callback of defaultsCallbacks) callback();
    needle.defaultsCallbacks = [];
    return rounds;
  }
  // Parses a JSON Schema sub-schema object - reentrant
  parseSubSchema(needle) {
    if (needle.schema == void 0) {
      this.throw(`No schema for path '${pathToString(needle.path)}'`, needle);
    }
    if (needle.schema.hasOwnProperty("not")) {
      let pass = false;
      try {
        this.parseSubSchema({
          ...needle,
          schema: needle.schema.not
        });
      } catch (e) {
        pass = true;
      }
      if (pass == false) {
        this.throw(`not at '${pathToString(needle.path)}' not met`, needle);
      }
    }
    if (needle.schema.hasOwnProperty("oneOf")) {
      const rounds = this.parseList(needle.schema.oneOf, needle, (r) => r !== 1);
      if (rounds !== 1) {
        if (needle.path.length == 0) {
          this.throw(`oneOf at '${pathToString(needle.path)}' not met, ${rounds} matches`, needle);
        }
        return 0;
      }
      return 1;
    }
    if (needle.schema.hasOwnProperty("anyOf")) {
      if (this.parseList(needle.schema.anyOf, needle, (r) => r !== 0) === 0) {
        if (needle.path.length == 0) {
          this.throw(`anyOf at '${pathToString(needle.path)}' not met`, needle);
        }
        return 0;
      }
      return 1;
    }
    if (needle.schema.hasOwnProperty("allOf")) {
      const conditions = needle.schema.allOf.reduce((r, c) => Object.assign(r, c), {});
      try {
        this.parseSubSchema({
          ...needle,
          schema: { type: needle.schema.type, ...conditions },
          carryProperties: true
        });
      } catch (e) {
        if (needle.path.length == 0) {
          throw e;
        }
        needle.errors.add(e.message);
        return 0;
      }
    }
    const { metadata, resolvedObject } = resolvePayload(needle.path, needle.payload);
    if (needle.schema.type === "array" && !metadata.types.has("binary") && !metadata.types.has("string")) {
      let matched = 0;
      for (let item in resolvedObject) {
        matched += this.parseSubSchema({
          ...needle,
          path: [...needle.path, item],
          schema: needle.schema.items
        });
      }
      return matched;
    } else if (needle.schema.type === "object" || needle.schema.properties) {
      return this.parseObject(needle) ? 1 : 0;
    } else if (resolvedObject !== void 0) {
      if (needle.schema.hasOwnProperty("const")) {
        if (resolvedObject !== needle.schema.const) {
          this.throw(
            `const ${resolvedObject} doesn't match ${needle.schema.const} at '${pathToString(needle.path)}'`,
            needle
          );
        } else {
          if (needle.schema.type == void 0) return 1;
        }
      }
      if (needle.schema.hasOwnProperty("enum")) {
        if (Array.isArray(needle.schema.enum)) {
          if (!needle.schema.enum.includes(resolvedObject)) {
            this.throw(
              `enum ${resolvedObject} not in ${needle.schema.enum.join(",")} at '${pathToString(needle.path)}'`,
              needle
            );
          } else {
            if (needle.schema.type == void 0) return 1;
          }
        } else {
          this.throw(`enum should be an array at '${pathToString(needle.path)}'`, needle);
        }
      }
      if (needle.schema.hasOwnProperty("type") && !metadata.types.has(needle.schema.type)) {
        this.throw(
          `Type mismatch of '${pathToString(needle.path)}', '${needle.schema.type}' not in ${Array.from(metadata.types).map((e) => `'${e}'`).join(",")}`,
          needle
        );
      }
      if (needle.schema !== true) {
        switch (needle.schema.type) {
          case "string":
            if (needle.schema.hasOwnProperty("maxLength") && metadata.size > needle.schema.maxLength) {
              this.throw(`Length of '${pathToString(needle.path)}' must be <= ${needle.schema.maxLength}`, needle);
            }
            if (needle.schema.hasOwnProperty("minLength") && metadata.size < needle.schema.minLength) {
              this.throw(
                `Length of '${pathToString(needle.path)}' must be >= ${needle.schema.minLength} not met`,
                needle
              );
            }
            break;
          case "number":
          case "integer":
            if (needle.schema.hasOwnProperty("minimum") && resolvedObject < needle.schema.minimum) {
              this.throw(`'${pathToString(needle.path)}' must be >= ${needle.schema.minimum}`, needle);
            }
            if (needle.schema.hasOwnProperty("exclusiveMinimum") && resolvedObject <= needle.schema.exclusiveMinimum) {
              this.throw(`'${pathToString(needle.path)}' must be > ${needle.schema.exclusiveMinimum}`, needle);
            }
            if (needle.schema.hasOwnProperty("maximum") && resolvedObject > needle.schema.maximum) {
              this.throw(`'${pathToString(needle.path)}' must be <= ${needle.schema.maximum}`, needle);
            }
            if (needle.schema.hasOwnProperty("exclusiveMaximum") && resolvedObject >= needle.schema.exclusiveMaximum) {
              this.throw(`'${pathToString(needle.path)}' must be < ${needle.schema.exclusiveMaximum}`, needle);
            }
            if (needle.schema.hasOwnProperty("multipleOf") && resolvedObject % needle.schema.multipleOf !== 0) {
              this.throw(`'${pathToString(needle.path)}' must be multiple of ${needle.schema.multipleOf}`, needle);
            }
            break;
        }
      }
      if (needle.schema.hasOwnProperty("pattern")) {
        let passes = false;
        try {
          if (new RegExp(needle.schema.pattern).test(resolvedObject)) passes = true;
        } catch (e) {
        }
        if (!passes) this.throw(`'${pathToString(needle.path)}' failed test ${needle.schema.pattern} patttern`, needle);
      }
      if (needle.carryProperties) {
        needle.evaluatedProperties.add(pathToString(needle.path));
      }
      return 1;
    }
    if (this.options.applyDefaults === true && needle.schema.hasOwnProperty("default")) {
      const applyDefaults = () => {
        needle.path.reduce(function(prev, curr, index) {
          if (prev[curr] === void 0) {
            prev[curr] = {};
          }
          if (index == needle.path.length - 1) {
            prev[curr] = needle.schema.default;
            needle.evaluatedProperties.add(pathToString(needle.path));
          }
          return prev ? prev[curr] : void 0;
        }, needle.payload);
      };
      if (needle.deferredApplyDefaults === true) {
        needle.defaultsCallbacks.push(applyDefaults);
      } else {
        applyDefaults();
      }
    }
    return 0;
  }
  validate(payload) {
    const needle = {
      errors: /* @__PURE__ */ new Set(),
      defaultsCallbacks: [],
      evaluatedProperties: /* @__PURE__ */ new Set(),
      path: [],
      schema: this.schema,
      payload
    };
    this.parseSubSchema(needle);
    return true;
  }
};
export {
  Cabidela
};
